Directory structure:
└── functions/
    ├── actions.mdx
    ├── bundling.mdx
    ├── debugging.mdx
    ├── http-actions.mdx
    ├── internal-functions.mdx
    ├── mutation-functions.mdx
    ├── query-functions.mdx
    ├── runtimes.mdx
    ├── validation.mdx
    └── error-handling/
        ├── application-errors.mdx
        └── error-handling.mdx

================================================
FILE: npm-packages/docs/docs/functions/actions.mdx
================================================
---
title: Actions
sidebar_position: 30
description: "Call third-party services and external APIs from Convex"
---

import Constructor from "!!raw-loader!@site/../private-demos/snippets/convex/actionsConstructor.ts";
import ArgsWithValidation from "!!raw-loader!@site/../private-demos/snippets/convex/actionsArgsWithValidation.ts";
import Context from "!!raw-loader!@site/../private-demos/snippets/convex/actionsContext.ts";
import ContextRunQuery from "!!raw-loader!@site/../private-demos/snippets/convex/myFunctions.ts";
import ContextRunMutation from "!!raw-loader!@site/../private-demos/snippets/convex/actionsContextRunMutation.ts";
import CircularError from "!!raw-loader!@site/../private-demos/snippets/convex/actionsCircularError.ts";
import CircularErrorFixedResults from "!!raw-loader!@site/../private-demos/snippets/convex/actionsCircularErrorFixedResults.ts";
import CircularErrorFixedReturn from "!!raw-loader!@site/../private-demos/snippets/convex/actionsCircularErrorFixedReturn.ts";
import NPM from "!!raw-loader!@site/../private-demos/snippets/convex/actionsNPM.ts";
import Node from "!!raw-loader!@site/../private-demos/snippets/convex/actionsNode.ts";
import Call from "!!raw-loader!@site/../private-demos/snippets/src/actionsCall.tsx";
import ScheduleFromMutation from "!!raw-loader!@site/../private-demos/snippets/convex/actionsScheduleFromMutation.ts";

Actions can call third party services to do things such as processing a payment
with [Stripe](https://stripe.com). They can be run in Convex's JavaScript
environment or in Node.js. They can interact with the database indirectly by
calling [queries](/functions/query-functions.mdx) and
[mutations](/functions/mutation-functions.mdx).

**Example:**
[GIPHY Action](https://github.com/get-convex/convex-demos/tree/main/giphy-action)

## Action names

Actions follow the same naming rules as queries, see
[Query names](/functions/query-functions.mdx#query-names).

## The `action` constructor

To declare an action in Convex you use the action constructor function. Pass it
an object with a `handler` function, which performs the action:

<TSAndJSSnippet
  sourceTS={Constructor}
  sourceJS={Constructor}
  title="convex/myFunctions.ts"
/>

Unlike a query, an action can but does not have to return a value.

### Action arguments and responses

Action arguments and responses follow the same rules as
[mutations](/functions/mutation-functions.mdx#mutation-arguments):

<TSAndJSSnippet
  sourceTS={ArgsWithValidation}
  sourceJS={ArgsWithValidation}
  title="convex/myFunctions.ts"
/>

The first argument to the handler function is reserved for the action context.

### Action context

The `action` constructor enables interacting with the database, and other Convex
features by passing an [ActionCtx](/api/interfaces/server.GenericActionCtx)
object to the handler function as the first argument:

<TSAndJSSnippet
  sourceTS={Context}
  sourceJS={Context}
  title="convex/myFunctions.ts"
/>

Which part of that action context is used depends on what your action needs to
do:

- To read data from the database use the `runQuery` field, and call a query that
  performs the read:

  <TSAndJSSnippet
    sourceTS={ContextRunQuery}
    sourceJS={ContextRunQuery}
    snippet="action"
    title="convex/myFunctions.ts"
  />

  Here `readData` is an [internal query](/functions/internal-functions.mdx)
  because we don't want to expose it to the client directly. Actions, mutations
  and queries can be defined in the same file.

- To write data to the database use the `runMutation` field, and call a mutation
  that performs the write:

  <TSAndJSSnippet
    sourceTS={ContextRunMutation}
    sourceJS={ContextRunMutation}
    title="convex/myFunctions.ts"
  />

  Use an [internal mutation](/functions/internal-functions.mdx) when you want to
  prevent users from calling the mutation directly.

  As with queries, it's often convenient to define actions and mutations in the
  same file.

- To generate upload URLs for storing files use the `storage` field. Read on
  about [File Storage](/file-storage.mdx).
- To check user authentication use the `auth` field. Auth is propagated
  automatically when calling queries and mutations from the action. Read on
  about [Authentication](/auth.mdx).
- To schedule functions to run in the future, use the `scheduler` field. Read on
  about [Scheduled Functions](/scheduling/scheduled-functions.mdx).
- To search a vector index, use the `vectorSearch` field. Read on about
  [Vector Search](/search/vector-search.mdx).

### Dealing with circular type inference

<Details summary={<>
Working around the TypeScript error: some action <code>implicitly has
type 'any' because it does not have a type annotation and is
referenced directly or indirectly in its own initializer.</code>
</>}>

When the return value of an action depends on the result of calling
`ctx.runQuery` or `ctx.runMutation`, TypeScript will complain that it cannot
infer the return type of the action. This is a minimal example of the issue:

<Snippet
  title="convex/myFunctions.ts"
  source={CircularError}
  snippet="tsError"
/>

To work around this, there are two options:

1. Type the return value of the handler function explicitly:
   <Snippet
     title="convex/myFunctions.ts"
     source={CircularErrorFixedReturn}
     snippet="fixed"
     highlightPatterns={["null"]}
   />
2. Type the the result of the `ctx.runQuery` or `ctx.runMutation` call
   explicitly:
   <Snippet
     title="convex/myFunctions.ts"
     source={CircularErrorFixedResults}
     snippet="fixed"
     highlightPatterns={["null"]}
   />

TypeScript will check that the type annotation matches what the called query or
mutation returns, so you don't lose any type safety.

In this trivial example the return type of the query was `null`. See the
[TypeScript](/understanding/best-practices/typescript.mdx#type-annotating-server-side-helpers)
page for other types which might be helpful when annotating the result.

</Details>

## Choosing the runtime ("use node")

Actions can run in Convex's custom JavaScript environment or in Node.js.

By default, actions run in Convex's environment. This environment supports
`fetch`, so actions that simply want to call a third-party API using `fetch` can
be run in this environment:

<TSAndJSSnippet sourceTS={NPM} sourceJS={NPM} title="convex/myFunctions.ts" />

Actions running in Convex's environment are faster compared to Node.js, since
they don't require extra time to start up before running your action (cold
starts). They can also be defined in the same file as other Convex functions.
Like queries and mutations they can import NPM packages, but not all are
supported.

Actions needing unsupported NPM packages or Node.js APIs can be configured to
run in Node.js by adding the `"use node"` directive at the top of the file. Note
that other Convex functions cannot be defined in files with the `"use node";`
directive.

<TSAndJSSnippet
  sourceTS={Node}
  sourceJS={Node}
  highlightPatterns={["use node"]}
  title="convex/myAction.ts"
/>

Learn more about the two [Convex Runtimes](/functions/runtimes.mdx).

## Splitting up action code via helpers

<>
  {/* Fragment for Prettier */}
  Just like with [queries](/functions/query-functions.mdx#splitting-up-query-code-via-helpers)
  and [mutations](/functions/mutation-functions.mdx#splitting-up-mutation-code-via-helpers)
  you can define and call helper
  <LanguageSelector verbose /> functions to split up the code in your actions or
  reuse logic across multiple Convex functions.

But note that the [ActionCtx](/api/interfaces/server.GenericActionCtx) only has
the `auth` field in common with [QueryCtx](/generated-api/server.md#queryctx)
and [MutationCtx](/generated-api/server.md#mutationctx).

</>

## Calling actions from clients

To call an action from [React](/client/react.mdx) use the
[`useAction`](/api/modules/react#useaction) hook along with the generated
[`api`](/generated-api/api) object.

<TSAndJSSnippet sourceTS={Call} sourceJS={Call} title="src/myApp.tsx" />

Unlike
[mutations](/functions/mutation-functions.mdx#calling-mutations-from-clients),
actions from a single client are parallelized. Each action will be executed as
soon as it reaches the server (even if other actions and mutations from the same
client are running). If your app relies on actions running after other actions
or mutations, make sure to only trigger the action after the relevant previous
function completes.

**Note:** In most cases calling an action directly from a client **is an
anti-pattern**. Instead, have the client call a
[mutation](/functions/mutation-functions.mdx) which captures the user intent by
writing into the database and then
[schedules](/scheduling/scheduled-functions.mdx) an action:

<TSAndJSSnippet
  sourceTS={ScheduleFromMutation}
  sourceJS={ScheduleFromMutation}
  title="convex/myFunctions.ts"
/>

This way the mutation can enforce invariants, such as preventing the user from
executing the same action twice.

## Limits

Actions time out after 10 minutes.
[Node.js](/functions/runtimes.mdx#nodejs-runtime) and
[Convex runtime](/functions/runtimes.mdx#default-convex-runtime) have 512MB and
64MB memory limit respectively. Please [contact us](/production/contact.md) if
you have a use case that requires configuring higher limits.

Actions can do up to 1000 concurrent operations, such as executing queries,
mutations or performing fetch requests.

For information on other limits, see [here](/production/state/limits.mdx).

## Error handling

Unlike queries and mutations, actions may have side-effects and therefore can't
be automatically retried by Convex when errors occur. For example, say your
action calls Stripe to send a customer invoice. If the HTTP request fails,
Convex has no way of knowing if the invoice was already sent. Like in normal
backend code, it is the responsibility of the caller to handle errors raised by
actions and retry the action call if appropriate.

## Dangling promises

Make sure to await all promises created within an action. Async tasks still
running when the function returns might or might not complete. In addition,
since the Node.js execution environment might be reused between action calls,
dangling promises might result in errors in subsequent action invocations.

## Best practices

### `await ctx.runAction` should only be used for crossing JS runtimes

**Why?** `await ctx.runAction` incurs to overhead of another Convex server
function. It counts as an extra function call, it allocates its own system
resources, and while you're awaiting this call the parent action call is frozen
holding all it's resources. If you pile enough of these calls on top of each
other, your app may slow down significantly.

**Fix:** The reason this api exists is to let you run code in the
[Node.js environment](/functions/runtimes.mdx). If you want to call an action
from another action that's in the same runtime, which is the normal case, the
best way to do this is to pull the code you want to call into a TypeScript
[helper function](/understanding/best-practices/best-practices.mdx#use-helper-functions-to-write-shared-code)
and call the helper instead.

### Avoid `await ctx.runMutation` / `await ctx.runQuery`

```ts
// ❌
const foo = await ctx.runQuery(...)
const bar = await ctx.runQuery(...)

// ✅
const fooAndBar = await ctx.runQuery(...)
```

**Why?** Multiple runQuery / runMutations execute in separate transactions and
aren’t guaranteed to be consistent with each other (e.g. foo and bar could read
the same document and return two different results), while a single runQuery /
runMutation will always be consistent. Additionally, you’re paying for multiple
function calls when you don’t have to.

**Fix:** Make a new internal query / mutation that does both things. Refactoring
the code for the two functions into helpers will make it easy to create a new
internal function that does both things while still keeping around the original
functions. Potentially try and refactor your action code to “batch” all the
database access.

Caveats: Separate runQuery / runMutation calls are valid when intentionally
trying to process more data than fits in a single transaction (e.g. running a
migration, doing a live aggregate).



================================================
FILE: npm-packages/docs/docs/functions/bundling.mdx
================================================
---
title: "Bundling"
sidebar_position: 90
description: "How Convex bundles and optimizes your function code"
---

Bundling is the process of gathering, optimizing and transpiling the JS/TS
source code of [functions](/functions.mdx) and their dependencies. During
development and when deploying, the code is transformed to a format that Convex
[runtimes](/functions/runtimes.mdx) can directly and efficiently execute.

Convex currently bundles all dependencies automatically, but for the Node.js
runtime you can disable bundling certain packages via the
[external packages](#external-packages) config.

## Bundling for Convex

When you push code either via `npx convex dev` or `npx convex deploy`, the
Convex CLI uses [esbuild](https://esbuild.github.io/) to traverse your `convex/`
folder and bundle your functions and all of their used dependencies into a
source code bundle. This bundle is then sent to the server.

Thanks to bundling you can write your code using both modern ECMAScript Modules
(ESM) or the older CommonJS (CJS) syntax.

<Details summary="ESM vs. CJS">
    ESM
    - Is the standard for browser Javascript
    - Uses static imports via the `import` and `export` **keywords** (not functions)
    at the global scope
    - Also supports dynamic imports via the asynchronous `import` function

    CJS
    - Was previously the standard module system for Node.js
    - Relies on dynamic imports via the `require` and asynchronous `import`
    functions for fetching external modules
    - Uses the `module.exports` object for exports

</Details>

## Bundling limitations

The nature of bundling comes with a few limitations.

### Code size limits

The total size of your bundled function code in your `convex/` folder is
**limited to 32MiB (~33.55MB)**. Other platform limits can be found
[here](/production/state/limits.mdx).

While this limit in itself is quite high for just source code, certain
dependencies can quickly make your bundle size cross over this limit,
particularly if they are not effectively
[tree-shakeable](https://webpack.js.org/guides/tree-shaking/) (such as
[aws-sdk](https://www.npmjs.com/package/aws-sdk) or
[snowflake-sdk](https://www.npmjs.com/package/snowflake-sdk))

You can follow these steps to debug bundle size:

<StepByStep>
  <Step title="Make sure you're using the most recent version of convex">
    ```sh
    npm install convex@latest
    ```
  </Step>
  <Step title="Generate the bundle">
   Note that this will not push code, and just generated a bundle for debugging purposes.

    ```sh
    npx convex dev --once --debug-bundle-path /tmp/myBundle
    ```

  </Step>
  <Step title="Visualize the bundle">
  Use
   [source-map-explorer](https://github.com/danvk/source-map-explorer/tree/master)
   to visualize your bundle.

    ```sh
    npx source-map-explorer /tmp/myBundle/**/*.js
    ```

  </Step>
</StepByStep>

Code bundled for the Convex runtime will be in the `isolate` directory while
code bundled for node actions will be in the `node` directory.

Large node dependencies can be eliminated from the bundle by marking them as
[external packages](/functions/bundling.mdx#external-packages).

### Dynamic dependencies

Some libraries rely on dynamic imports (via `import`/`require` calls) to avoid
always including their dependencies. These imports are not supported by the
[default Convex runtime](/functions/runtimes.mdx#default-convex-runtime) and
will throw an error at runtime.

Additionally, some libraries rely on local files, which cannot be bundled by
esbuild. If bundling is used, irrespective of the choice of runtime, these
imports will always fail in Convex.

<Details summary="Examples of libraries with dynamic dependencies">

Consider the following examples of packages relying on dynamic dependencies:

- [langchain](https://www.npmjs.com/package/langchain) relying on the presence
  of peer dependencies that it can dynamically import. These dependencies are
  not statically `import`ed so will not be bundled by `esbuild`.
- [sharp](https://www.npmjs.com/package/sharp) relying on the presence of
  `libvips` binaries for image-processing operations
- [pdf-parse](https://www.npmjs.com/package/pdf-parse) relies on being
  dynamically imported with `require()` in order to detect if it is being run in
  test mode. Bundling can eliminate these `require()` calls, making `pdf-parse`
  assume it is running in test mode.
- [tiktoken](https://www.npmjs.com/package/tiktoken) relying on local WASM files

</Details>

## External packages

As a workaround for the bundling limitations above, Convex provides an escape
hatch: **external packages**. This feature is currently exclusive to Convex's
[Node.js runtime](/functions/runtimes.mdx#nodejs-runtime).

External packages use
[`esbuild`'s facility for marking a dependency as external](https://esbuild.github.io/api/#external).
This tells `esbuild` to not bundle the external dependency at all and to leave
the import as a dynamic runtime import using `require()` or `import()`. Thus,
your Convex modules will rely on the underlying system having that dependency
made available at execution-time.

### Package installation on the server

Packages marked as external are installed from [npm](https://www.npmjs.com/) the
first time you push code that uses them. The version installed matches the
version installed in the `node_modules` folder on your local machine.

While this comes with a latency penalty the first time you push external
packages, your packages are cached and this install step only ever needs to
rerun if your external packages change. Once cached, pushes can actually be
faster due to smaller source code bundles being sent to the server during
pushes!

### Specifying external packages

Create a [`convex.json`](/production/project-configuration.mdx#convexjson) file
in the same directory as your `package.json` if it does not exist already. Set
the `node.externalPackages` field to `["*"]` to mark all dependencies used
within your Node actions as external:

```json
{
  "node": {
    "externalPackages": ["*"]
  }
}
```

Alternatively, you can explicitly specify which packages to mark as external:

```json
{
  "node": {
    "externalPackages": ["aws-sdk", "sharp"]
  }
}
```

The package identifiers should match the string used in `import`/`require` in
your [Node.js action](/functions/actions.mdx#choosing-the-runtime-use-node).

### Troubleshooting external packages

#### Incorrect package versions

The Convex CLI searches for external packages within your local `node_modules`
directory. Thus, changing version of a package in the `package.json` will not
affect the version used on the server until you've updated the package version
installed in your local `node_modules` folder (e.g. running `npm install`).

#### Import errors

Marking a dependency as external may result in errors like this:

> The requested module "some-module" is a CommonJs module, which may not support
> all module.exports as named exports. CommonJs modules can always be imported
> via the default export

This requires rewriting any imports for this module as follows:

```ts
// ❌ old
import { Foo } from "some-module";

// ✅ new
import SomeModule from "some-module";
const { Foo } = SomeModule;
```

### Limitations

The total size of your source code bundle and external packages cannot exceed
the following:

- 45MB zipped
- 240MB unzipped

Packages that are known not to work at this time:

- [Puppeteer](https://www.npmjs.com/package/puppeteer) - browser binary
  installation exceeds the size limit
- [@ffmpeg.wasm](https://www.npmjs.com/package/@ffmpeg/ffmpeg) - since 0.12.0,
  [no longer supports Node environments](https://ffmpegwasm.netlify.app/docs/faq#why-ffmpegwasm-doesnt-support-nodejs)

If there is a package that you would like working in your Convex functions,
[let us know](https://convex.dev/community).



================================================
FILE: npm-packages/docs/docs/functions/debugging.mdx
================================================
---
title: Debugging
sidebar_position: 100
description: "Debug Convex functions during development and production"
---

Debugging is the process of figuring out why your code isn't behaving as you
expect.

## Debugging during development

During development the built-in `console` API allows you to understand what's
going on inside your functions:

```ts title="convex/myFunctions.ts"
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const mutateSomething = mutation({
  args: { a: v.number(), b: v.number() },
  handler: (_, args) => {
    console.log("Received args", args);
    // ...
  },
});
```

The following methods are available in the
[default Convex runtime](/functions/runtimes.mdx#default-convex-runtime):

- Logging values, with a specified severity level:
  - `console.log`
  - `console.info`
  - `console.warn`
  - `console.error`
  - `console.debug`
- Logging with a stack trace:
  - [`console.trace`](https://developer.mozilla.org/en-US/docs/Web/API/console/trace_static)
- Measuring execution time:
  - [`console.time`](https://developer.mozilla.org/en-US/docs/Web/API/console/time_static)
  - [`console.timeLog`](https://developer.mozilla.org/en-US/docs/Web/API/console/timelog_static)
  - [`console.timeEnd`](https://developer.mozilla.org/en-US/docs/Web/API/console/timeend_static)

The Convex backend also automatically logs all successful function executions
and all errors thrown by your functions.

You can view these logs:

1. When using the [`ConvexReactClient`](/client/react.mdx), in your browser
   developer tools console pane. The logs are sent from your dev deployment to
   your client, and the client logs them to the browser. Production deployments
   [**do not** send logs to the client](/functions/error-handling/error-handling.mdx#differences-in-error-reporting-between-dev-and-prod).
2. In your Convex dashboard on the [Logs page](/dashboard/deployments/logs.md).
3. In your terminal with [`npx convex dev`](/cli.md#tail-deployment-logs) during
   development or [`npx convex logs`](/cli.md#tail-deployment-logs), which only
   prints logs.

### Using a debugger

You can exercise your functions from tests, in which case you can add
`debugger;` statements and step through your code. See
[Testing](/testing/convex-test.mdx#debugging-tests).

## Debugging in production

When debugging an issue in production your options are:

1. Leverage existing logging
2. Add more logging and deploy a new version of your backend to production

Convex backend currently only preserves a limited number of logs, and logs can
be erased at any time when the Convex team performs internal maintenance and
upgrades. You should therefore set up
[log streaming and error reporting](/production/integrations/integrations.mdx)
integrations to enable your team easy access to historical logs and additional
information logged by your client.

## Finding relevant logs by Request ID

To find the appropriate logs for an error you or your users experience, Convex
includes a Request ID in all exception messages in both dev and prod in this
format: `[Request ID: <request_id>]`.

You can copy and paste a Request ID into your Convex dashboard to view the logs
for functions started by that request. See the
[Dashboard logs page](/dashboard/deployments/logs.md#filter-logs) for details.

{/* TODO: Document how to filter by Request ID in Datadog/Axiom */}



================================================
FILE: npm-packages/docs/docs/functions/http-actions.mdx
================================================
---
title: HTTP Actions
sidebar_position: 35
description: "Build HTTP APIs directly in Convex"
---

import http from "!!raw-loader!@site/../demos/http/convex/http.ts";
import httpFunction from "!!raw-loader!@site/../private-demos/snippets/convex/httpActionExample.ts";
import Constructor from "!!raw-loader!@site/../private-demos/snippets/convex/httpActionConstructor.ts";
import httpStorage from "!!raw-loader!@site/../demos/file-storage-with-http/convex/http.ts";
import Fetch from "!!raw-loader!@site/../private-demos/snippets/src/httpAuthCall.ts";

HTTP actions allow you to build an HTTP API right in Convex!

HTTP actions take in a
[Request](https://developer.mozilla.org/en-US/docs/Web/API/Request) and return a
[Response](https://developer.mozilla.org/en-US/docs/Web/API/Response) following
the [Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).
HTTP actions can manipulate the request and response directly, and interact with
data in Convex indirectly by running [queries](/functions/query-functions.mdx),
[mutations](/functions/mutation-functions.mdx), and
[actions](/functions/actions.mdx). HTTP actions might be used for receiving
webhooks from external applications or defining a public HTTP API.

HTTP actions are exposed at `https://<your deployment name>.convex.site` (e.g.
`https://happy-animal-123.convex.site`).

**Example:**
[HTTP Actions](https://github.com/get-convex/convex-demos/tree/main/http)

## Defining HTTP actions

HTTP action handlers are defined using the
[`httpAction`](/generated-api/server#httpaction) constructor, similar to the
`action` constructor for normal actions:

<TSAndJSSnippet
  title="convex/myHttpActions.ts"
  sourceTS={Constructor}
  sourceJS={Constructor}
/>

The first argument to the `handler` is an
[`ActionCtx`](/api/interfaces/server.GenericActionCtx) object, which provides
[`auth`](/api/interfaces/server.Auth),
[`storage`](/api/interfaces/server.StorageActionWriter), and
[`scheduler`](/api/interfaces/server.Scheduler), as well as `runQuery`,
`runMutation`, `runAction`.

The second argument contains the
[`Request`](https://developer.mozilla.org/en-US/docs/Web/API/Request) data. HTTP
actions do not support argument validation, as the parsing of arguments from the
incoming Request is left entirely to you.

Here's an example:

<TSAndJSSnippet
  title="convex/messages.ts"
  sourceTS={httpFunction}
  sourceJS={httpFunction}
/>

<>
  {/* Wrapped in fragment because Prettier pushes the JSDialectFileName on new line */}
  To expose the HTTP Action, export an instance of
  [`HttpRouter`](/api/classes/server.HttpRouter) from the
  <JSDialectFileName name="convex/http.ts" /> file. To create the instance call
  the `httpRouter` function. On the `HttpRouter` you can expose routes using the
  `route` method:
</>

<TSAndJSSnippet
  title="convex/http.js"
  sourceTS={http}
  sourceJS={http}
  snippet="router"
  highlightPatterns={["handler: postMessage"]}
/>

You can now call this action via HTTP and interact with data stored in the
Convex Database. HTTP actions are exposed on
`https://<your deployment name>.convex.site`.

```bash
export DEPLOYMENT_NAME=... # example: "happy-animal-123"
curl -d '{ "author": "User 123", "body": "Hello world" }' \
    -H 'content-type: application/json' "https://$DEPLOYMENT_NAME.convex.site/postMessage"
```

Like other Convex functions, you can view your HTTP actions in the
[Functions view](/dashboard/deployments/functions.md) of
[your dashboard](https://dashboard.convex.dev/) and view logs produced by them
in the [Logs view](/dashboard/deployments/logs.md).

## Limits

HTTP actions run in the same environment as queries and mutations so also do not
have access to Node.js-specific JavaScript APIs. HTTP actions can call
[actions](/functions/actions.mdx), which can run in Node.js.

Like [actions](/functions/actions.mdx#error-handling), HTTP actions may have
side-effects and will not be automatically retried by Convex when errors occur.
It is a responsibility of the caller to handle errors and retry the request if
appropriate.

Request and response size is limited to 20MB.

HTTP actions support request and response body types of `.text()`, `.json()`,
`.blob()`, and `.arrayBuffer()`.

Note that you don't need to define an HTTP action to call your queries,
mutations and actions over HTTP if you control the caller, since you can use use
the JavaScript [`ConvexHttpClient`](/api/classes/browser.ConvexHttpClient) or
the [Python client](/client/python.md) to call these functions directly.

## Debugging

### Step 1: Check that your HTTP actions were deployed.

Check the [functions page](https://dashboard.convex.dev/deployment/functions) in
the dashboard and make sure there's an entry called `http`.

If not, double check that you've defined your HTTP actions with the `httpRouter`
in a file called `http.js` or `http.ts` (the name of the file must match
exactly), and that `npx convex dev` has no errors.

### Step 2: Check that you can access your endpoint using curl

Get your URL from the dashboard under
[Settings](https://dashboard.convex.dev/deployment/settings) > URL and Deploy
Key.

Make sure this is the URL that ends in **`.convex.site`**, and not
`.convex.cloud`. E.g. `https://happy-animal-123.convex.site`

Run a `curl` command to hit one of your defined endpoints, potentially defining
a new endpoint specifically for testing

```
curl -X GET https://<deployment name>.convex.site/myEndpoint
```

Check the [logs page](https://dashboard.convex.dev/deployment/logs) in the
dashboard to confirm that there's an entry for your HTTP action.

### Step 3: Check the request being made by your browser

If you've determined that your HTTP actions have been deployed and are
accessible via curl, but there are still issues requesting them from your app,
check the exact requests being made by your browser.

Open the _Network_ tab in your browser's developer tools, and trigger your HTTP
requests.

Check that this URL matches what you tested earlier with curl -- it ends in
`.convex.site` and has the right deployment name.

You should be able to see these requests in the dashboard
[logs page](https://dashboard.convex.dev/deployment/logs).

If you see "CORS error" or messages in the browser console like
`Access to fetch at '...' from origin '...' has been blocked by CORS policy`,
you likely need to configure CORS headers and potentially add a handler for the
pre-flight `OPTIONS` request. See
[this section](/functions/http-actions.mdx#cors) below.

## Common patterns

### File Storage

HTTP actions can be used to handle uploading and fetching stored files, see:

- [Uploading files via an HTTP action](/file-storage/upload-files.mdx#uploading-files-via-an-http-action)
- [Serving files from HTTP actions](/file-storage/serve-files.mdx#serving-files-from-http-actions)

### CORS

To make requests to HTTP actions from a website you need to add
[Cross-Origin Resource Sharing (CORS)](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS)
headers to your HTTP actions.

There are existing resources for exactly which CORS headers are required based
on the use case. [This site](https://httptoolkit.com/will-it-cors/) provides an
interactive walkthrough for what CORS headers to add. Here's an example of
adding CORS headers to a Convex HTTP action:

<TSAndJSSnippet
  title="convex/http.ts"
  sourceTS={httpStorage}
  sourceJS={httpStorage}
  snippet={["sendImageStore"]}
  highlightPatterns={["headers: new Headers", "        ", "     \\}\\)"]}
/>

Here's an example of handling a pre-flight `OPTIONS` request:

<TSAndJSSnippet
  title="convex/http.ts"
  sourceTS={httpStorage}
  sourceJS={httpStorage}
  snippet="preflight"
  highlightPatterns={["headers: new Headers", "          ", "       \\}\\)"]}
/>

### Authentication

You can leverage Convex's built-in [authentication](/auth.mdx) integration and
access a user identity from
[`ctx.auth.getUserIdentity()`](/api/interfaces/server.Auth#getuseridentity). To
do this call your endpoint with an `Authorization` header including a JWT token:

<TSAndJSSnippet sourceTS={Fetch} sourceJS={Fetch} title="myPage.ts" />



================================================
FILE: npm-packages/docs/docs/functions/internal-functions.mdx
================================================
---
title: Internal Functions
sidebar_position: 40
description: "Functions that can only be called by other Convex functions"
---

import Definition from "!!raw-loader!@site/../private-demos/snippets/convex/plans.ts";
import Call from "!!raw-loader!@site/../private-demos/snippets/convex/internalFunctionsCall.ts";
import DefinitionWithoutValidationTS from "!!raw-loader!@site/../private-demos/snippets/convex/internalFunctionsDefinitionWithoutValidation.ts";
import DefinitionWithoutValidationJS from "!!raw-loader!@site/../private-demos/snippets/convex/internalFunctionsDefinitionWithoutValidationJS.js";

Internal functions can only be called by other [functions](/functions.mdx) and
cannot be called directly from a [Convex client](/client/react.mdx).

By default your Convex functions are public and accessible to clients. Public
functions may be called by malicious users in ways that cause surprising
results. Internal functions help you mitigate this risk. We recommend using
internal functions any time you're writing logic that should not be called from
a client.

While internal functions help mitigate risk by reducing the public surface area
of your application, you can still validate internal invariants using
[argument validation](/functions/validation.mdx) and/or
[authentication](/auth/functions-auth.mdx).

## Use cases for internal functions

Leverage internal functions by:

- Calling them from [actions](/functions/actions.mdx#action-context) via
  `runQuery` and `runMutation`
- Calling them from [HTTP actions](/functions/http-actions.mdx) via `runQuery`,
  `runMutation`, and `runAction`
- [Scheduling](/scheduling/scheduled-functions.mdx) them from other functions to
  run in the future
- Scheduling them to run periodically from
  [cron jobs](/scheduling/cron-jobs.mdx)
- Running them using the
  [Dashboard](/dashboard/deployments/functions.md#running-functions)
- Running them from the [CLI](/cli.md#run-convex-functions)

## Defining internal functions

An internal function is defined using `internalQuery`, `internalMutation`, or
`internalAction`. For example:

<TSAndJSSnippet
  title="convex/plans.ts"
  sourceTS={Definition}
  sourceJS={Definition}
  highlightPatterns={["internalMutation"]}
/>

If you need to pass complicated objects to internal functions you might prefer
to not use argument validation. Note though that if you're using `internalQuery`
or `internalMutation` it's a better idea to pass around document IDs instead of
documents, to ensure the query or mutation is working with the up-to-date state
of the database.

<Details summary="Internal function without argument validation">

<TSAndJSSnippet
  title="convex/plans.ts"
  sourceTS={DefinitionWithoutValidationTS}
  sourceJS={DefinitionWithoutValidationJS}
  highlightPatterns={[": {"]}
/>

</Details>

## Calling internal functions

Internal functions can be called from actions and scheduled from actions and
mutation using the [`internal`](/generated-api/api#internal) object.

For example, consider this public `upgrade` action that calls the internal
`plans.markPlanAsProfessional` mutation we defined above:

<TSAndJSSnippet title="convex/changes.ts" sourceTS={Call} sourceJS={Call} />

In this example a user should not be able to directly call
`internal.plans.markPlanAsProfessional` without going through the `upgrade`
action — if they did, then they would get a free upgrade.

You can define public and internal functions in the same file.



================================================
FILE: npm-packages/docs/docs/functions/mutation-functions.mdx
================================================
---
title: Mutations
sidebar_position: 20
description: "Insert, update, and remove data from the database"
---

import Example from "!!raw-loader!@site/../private-demos/snippets/convex/mutationsExample.ts";
import Constructor from "!!raw-loader!@site/../private-demos/snippets/convex/mutationsConstructor.ts";
import ArgsWithoutValidationTS from "!!raw-loader!@site/../private-demos/snippets/convex/mutationsArgsWithoutValidation.ts";
import ArgsWithoutValidationJS from "!!raw-loader!@site/../private-demos/snippets/convex/mutationsArgsWithoutValidationJS.js";
import ArgsWithValidation from "!!raw-loader!@site/../private-demos/snippets/convex/mutationsArgsWithValidation.ts";
import Context from "!!raw-loader!@site/../private-demos/snippets/convex/mutationsContext.ts";
import ContextDB from "!!raw-loader!@site/../private-demos/snippets/convex/mutationsContextDB.ts";
import Helper from "!!raw-loader!@site/../private-demos/snippets/convex/mutationsHelper.ts";
import HelperJS from "!!raw-loader!@site/../private-demos/snippets/convex/mutationsHelperJS.js";
import NPM from "!!raw-loader!@site/../private-demos/snippets/convex/mutationsNPM.ts";
import Call from "!!raw-loader!@site/../private-demos/snippets/src/mutationsCall.tsx";

Mutations insert, update and remove data from the database, check authentication
or perform other business logic, and optionally return a response to the client
application.

This is an example mutation, taking in named arguments, writing data to the
database and returning a result:

<TSAndJSSnippet
  sourceTS={Example}
  sourceJS={Example}
  title="convex/myFunctions.ts"
/>

Read on to understand how to build mutations yourself.

## Mutation names

Mutations follow the same naming rules as queries, see
[Query names](/functions/query-functions.mdx#query-names).

Queries and mutations can be defined in the same file when using named exports.

## The `mutation` constructor

To declare a mutation in Convex use the `mutation` constructor function. Pass it
an object with a `handler` function, which performs the mutation:

<TSAndJSSnippet
  sourceTS={Constructor}
  sourceJS={Constructor}
  title="convex/myFunctions.ts"
/>

Unlike a query, a mutation can but does not have to return a value.

### Mutation arguments

Just like queries, mutations accept named arguments, and the argument values are
accessible as fields of the second parameter of the `handler` function:

<TSAndJSSnippet
  sourceTS={ArgsWithoutValidationTS}
  sourceJS={ArgsWithoutValidationJS}
  title="convex/myFunctions.ts"
/>

Arguments and responses are automatically serialized and deserialized, and you
can pass and return most value-like JavaScript data to and from your mutation.

To both declare the types of arguments and to validate them, add an `args`
object using `v` validators:

<TSAndJSSnippet
  sourceTS={ArgsWithValidation}
  sourceJS={ArgsWithValidation}
  title="convex/myFunctions.ts"
/>

See [argument validation](/functions/validation.mdx) for the full list of
supported types and validators.

The first parameter to the handler function is reserved for the mutation
context.

### Mutation responses

Queries can return values of any supported
[Convex type](/functions/validation.mdx) which will be automatically serialized
and deserialized.

Mutations can also return `undefined`, which is not a valid Convex value. When a
mutation returns `undefined` **it is translated to `null`** on the client.

### Mutation context

The `mutation` constructor enables writing data to the database, and other
Convex features by passing a [MutationCtx](/generated-api/server.md#mutationctx)
object to the handler function as the first parameter:

<TSAndJSSnippet
  sourceTS={Context}
  sourceJS={Context}
  title="convex/myFunctions.ts"
/>

Which part of the mutation context is used depends on what your mutation needs
to do:

- To read from and write to the database use the `db` field. Note that we make
  the handler function an `async` function so we can `await` the promise
  returned by `db.insert()`:

  <TSAndJSSnippet
    sourceTS={ContextDB}
    sourceJS={ContextDB}
    title="convex/myFunctions.ts"
  />

  Read on about [Writing Data](/database/writing-data.mdx).

- To generate upload URLs for storing files use the `storage` field. Read on
  about [File Storage](/file-storage.mdx).
- To check user authentication use the `auth` field. Read on about
  [Authentication](/auth.mdx).
- To schedule functions to run in the future, use the `scheduler` field. Read on
  about [Scheduled Functions](/scheduling/scheduled-functions.mdx).

## Splitting up mutation code via helpers

<>
  {/* Fragment for Prettier */}
  When you want to split up the code in your mutation or reuse logic across
  multiple Convex functions you can define and call helper
  <LanguageSelector verbose /> functions:
</>

<TSAndJSSnippet
  sourceTS={Helper}
  sourceJS={HelperJS}
  title="convex/myFunctions.ts"
/>

Mutations can call helpers that take a
[QueryCtx](/generated-api/server.md#queryctx) as argument, since the mutation
context can do everything query context can.

You can `export` helpers to use them across multiple files. They will not be
callable from outside of your Convex functions.

See
[Type annotating server side helpers](/understanding/best-practices/typescript.mdx#type-annotating-server-side-helpers)
for more guidance on TypeScript types.

## Using NPM packages

Mutations can import NPM packages installed in `node_modules`. Not all NPM
packages are supported, see
[Runtimes](/functions/runtimes.mdx#default-convex-runtime) for more details.

```sh
npm install @faker-js/faker
```

<TSAndJSSnippet sourceTS={NPM} sourceJS={NPM} title="convex/myFunctions.ts" />

## Calling mutations from clients

To call a mutation from [React](/client/react.mdx) use the
[`useMutation`](/client/react.mdx#editing-data) hook along with the generated
[`api`](/generated-api/api) object.

<TSAndJSSnippet sourceTS={Call} sourceJS={Call} title="src/myApp.tsx" />

See the [React](/client/react.mdx) client documentation for all the ways queries
can be called.

When mutations are called from the [React](/client/react.mdx) or
[Rust](/client/rust.md) clients, they are executed one at a time in a single,
ordered queue. You don't have to worry about mutations editing the database in a
different order than they were triggered.

## Transactions

Mutations run **transactionally**. This means that:

1. All database reads inside the transaction get a consistent view of the data
   in the database. You don't have to worry about a concurrent update changing
   the data in the middle of the execution.
2. All database writes get committed together. If the mutation writes some data
   to the database, but later throws an error, no data is actually written to
   the database.

For this to work, similarly to queries, mutations must be deterministic, and
cannot call third party APIs. To call third party APIs, use
[actions](/functions/actions.mdx).

## Limits

Mutations have a limit to the amount of data they can read and write at once to
guarantee good performance. Learn more in
[Read/write limit errors](/functions/error-handling/error-handling.mdx#readwrite-limit-errors).

For information on other limits, see [Limits](/production/state/limits.mdx).



================================================
FILE: npm-packages/docs/docs/functions/query-functions.mdx
================================================
---
title: Queries
sidebar_position: 10
description: "Fetch data from the database with caching and reactivity"
---

import Example from "!!raw-loader!@site/../private-demos/snippets/convex/queriesExample.ts";
import Constructor from "!!raw-loader!@site/../private-demos/snippets/convex/queriesConstructor.ts";
import ArgsWithoutValidationTS from "!!raw-loader!@site/../private-demos/snippets/convex/queriesArgsWithoutValidation.ts";
import ArgsWithoutValidationJS from "!!raw-loader!@site/../private-demos/snippets/convex/queriesArgsWithoutValidationJS.js";
import ArgsWithValidation from "!!raw-loader!@site/../private-demos/snippets/convex/queriesArgsWithValidation.ts";
import Context from "!!raw-loader!@site/../private-demos/snippets/convex/queriesContext.ts";
import ContextDB from "!!raw-loader!@site/../private-demos/snippets/convex/queriesContextDB.ts";
import Helper from "!!raw-loader!@site/../private-demos/snippets/convex/queriesHelper.ts";
import HelperJS from "!!raw-loader!@site/../private-demos/snippets/convex/queriesHelperJS.js";
import NPM from "!!raw-loader!@site/../private-demos/snippets/convex/queriesNPM.ts";
import Call from "!!raw-loader!@site/../private-demos/snippets/src/queriesCall.tsx";

Queries are the bread and butter of your backend API. They fetch data from the
database, check authentication or perform other business logic, and return data
back to the client application.

This is an example query, taking in named arguments, reading data from the
database and returning a result:

<TSAndJSSnippet
  sourceTS={Example}
  sourceJS={Example}
  title="convex/myFunctions.ts"
/>

Read on to understand how to build queries yourself.

## Query names

Queries are defined in <LanguageSelector verbose /> files inside your `convex/`
directory.

The path and name of the file, as well as the way the function is exported from
the file, determine the name the client will use to call it:

```ts title="convex/myFunctions.ts"
// This function will be referred to as `api.myFunctions.myQuery`.
export const myQuery = …;

// This function will be referred to as `api.myFunctions.sum`.
export const sum = …;
```

To structure your API you can nest directories inside the `convex/` directory:

```ts title="convex/foo/myQueries.ts"
// This function will be referred to as `api.foo.myQueries.listMessages`.
export const listMessages = …;
```

Default exports receive the name `default`.

```ts title="convex/myFunctions.ts"
// This function will be referred to as `api.myFunctions.default`.
export default …;
```

The same rules apply to [mutations](/functions/mutation-functions.mdx) and
[actions](/functions/actions.mdx), while
[HTTP actions](/functions/http-actions.mdx) use a different routing approach.

Client libraries in languages other than JavaScript and TypeScript use strings
instead of API objects:

- `api.myFunctions.myQuery` is `"myFunctions:myQuery"`
- `api.foo.myQueries.myQuery` is `"foo/myQueries:myQuery"`.
- `api.myFunction.default` is `"myFunction:default"` or `"myFunction"`.

## The `query` constructor

To actually declare a query in Convex you use the `query` constructor function.
Pass it an object with a `handler` function, which returns the query result:

<TSAndJSSnippet
  sourceTS={Constructor}
  sourceJS={Constructor}
  title="convex/myFunctions.ts"
/>

### Query arguments

Queries accept named arguments. The argument values are accessible as fields of
the second parameter of the handler function:

<TSAndJSSnippet
  sourceTS={ArgsWithoutValidationTS}
  sourceJS={ArgsWithoutValidationJS}
  title="convex/myFunctions.ts"
/>

Arguments and responses are automatically serialized and deserialized, and you
can pass and return most value-like JavaScript data to and from your query.

To both declare the types of arguments and to validate them, add an `args`
object using `v` validators:

<TSAndJSSnippet
  sourceTS={ArgsWithValidation}
  sourceJS={ArgsWithValidation}
  highlightPatterns={["args:"]}
  title="convex/myFunctions.ts"
/>

See [argument validation](/functions/validation.mdx) for the full list of
supported types and validators.

The first parameter of the handler function contains the query context.

### Query responses

Queries can return values of any supported
[Convex type](/functions/validation.mdx) which will be automatically serialized
and deserialized.

Queries can also return `undefined`, which is not a valid Convex value. When a
query returns `undefined` **it is translated to `null`** on the client.

### Query context

The `query` constructor enables fetching data, and other Convex features by
passing a [QueryCtx](/generated-api/server.md#queryctx) object to the handler
function as the first parameter:

<TSAndJSSnippet
  sourceTS={Context}
  sourceJS={Context}
  title="convex/myFunctions.ts"
/>

Which part of the query context is used depends on what your query needs to do:

- To fetch from the database use the `db` field. Note that we make the handler
  function an `async` function so we can `await` the promise returned by
  `db.get()`:

  <TSAndJSSnippet
    sourceTS={ContextDB}
    sourceJS={ContextDB}
    highlightPatterns={["db."]}
    title="convex/myFunctions.ts"
  />

  Read more about [Reading Data](/database/reading-data/reading-data.mdx).

- To return URLs to stored files use the `storage` field. Read more about
  [File Storage](/file-storage.mdx).
- To check user authentication use the `auth` field. Read more about
  [Authentication](/auth.mdx).

## Splitting up query code via helpers

When you want to split up the code in your query or reuse logic across multiple
Convex functions you can define and call helper <LanguageSelector verbose />
functions:

<TSAndJSSnippet
  sourceTS={Helper}
  sourceJS={HelperJS}
  title="convex/myFunctions.ts"
/>

You can `export` helpers to use them across multiple files. They will not be
callable from outside of your Convex functions.

See
[Type annotating server side helpers](/understanding/best-practices/typescript.mdx#type-annotating-server-side-helpers)
for more guidance on TypeScript types.

## Using NPM packages

Queries can import NPM packages installed in `node_modules`. Not all NPM
packages are supported, see
[Runtimes](/functions/runtimes.mdx#default-convex-runtime) for more details.

```sh
npm install @faker-js/faker
```

<TSAndJSSnippet sourceTS={NPM} sourceJS={NPM} title="convex/myFunctions.ts" />

## Calling queries from clients

To call a query from [React](/client/react.mdx) use the
[`useQuery`](/client/react.mdx#fetching-data) hook along with the generated
[`api`](/generated-api/api) object.

<TSAndJSSnippet sourceTS={Call} sourceJS={Call} title="src/MyApp.tsx" />

See the [React](/client/react.mdx) client documentation for all the ways queries
can be called.

## Caching & reactivity & consistency

Queries have three awesome attributes:

1. **Caching**: Convex caches query results automatically. If many clients
   request the same query, with the same arguments, they will receive a cached
   response.
2. **Reactivity**: clients can subscribe to queries to receive new results when
   the underlying data changes.
3. **Consistency**: All database reads inside a single query call are performed
   at the same logical timestamp. Concurrent writes do not affect the query
   results.

To have these attributes the handler function must be _deterministic_, which
means that given the same arguments (including the query context) it will return
the same response.

For this reason queries cannot `fetch` from third party APIs. To call third
party APIs, use [actions](/functions/actions.mdx).

You might wonder whether you can use non-deterministic language functionality
like `Math.random()` or `Date.now()`. The short answer is that Convex takes care
of implementing these in a way that you don't have to think about the
deterministic constraint.

See [Runtimes](/functions/runtimes.mdx#default-convex-runtime) for more details
on the Convex runtime.

## Limits

Queries have a limit to the amount of data they can read at once to guarantee
good performance. Check out these limits in
[Read/write limit errors](/functions/error-handling/error-handling.mdx#readwrite-limit-errors).

For information on other limits, see [Limits](/production/state/limits.mdx).



================================================
FILE: npm-packages/docs/docs/functions/runtimes.mdx
================================================
---
title: Runtimes
sidebar_position: 80
description:
  "Learn the differences between the Convex and Node.js runtimes for functions"
---

# Runtimes

Convex functions can run in two runtimes:

- Default [Convex runtime](#default-convex-runtime)
- Opt-in [Node.js runtime](#nodejs-runtime)

## Default Convex runtime

All Convex backend functions are written in JavaScript or TypeScript. By default
all functions run in a custom JavaScript runtime very similar to the
[Cloudflare Workers runtime](https://blog.cloudflare.com/cloud-computing-without-containers/)
with access to most
[web standard globals](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects).

The default runtime has many advantages including:

- **No cold starts**. The runtime is always up, and ready to handle any function
  at a moments notice.
- **Latest web JavaScript standards**. The runtime is based on V8 that also
  powers Google Chrome. This ensures it provides an interface very similar to
  your frontend code, allowing further simplification to your code.
- **Low overhead access to your data**. The runtime is designed to have low
  overhead access to your data via query & mutation functions, allowing you to
  access your database via a simple
  [JavaScript interface](/database/reading-data/reading-data.mdx).

### Supported APIs

The default runtime supports most npm libraries that work in the browser,
[Deno](https://deno.com/), and
[Cloudflare workers](https://developers.cloudflare.com/workers/). If your
library isn't supported, you can use an action with the
[Node.js runtime](#nodejs-runtime), or reach out in
[Discord](https://convex.dev/community). We are improving support all the time.

#### Network APIs

- [Blob](https://developer.mozilla.org/en-US/docs/Web/API/Blob)
- [Event](https://developer.mozilla.org/en-US/docs/Web/API/Event)
- [EventTarget](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget)
- [fetch](https://developer.mozilla.org/en-US/docs/Web/API/fetch) — in
  [Actions](#actions) only
- [File](https://developer.mozilla.org/en-US/docs/Web/API/File)
- [FormData](https://developer.mozilla.org/en-US/docs/Web/API/FormData)
- [Headers](https://developer.mozilla.org/en-US/docs/Web/API/Headers)
- [Request](https://developer.mozilla.org/en-US/docs/Web/API/Request)
- [Response](https://developer.mozilla.org/en-US/docs/Web/API/Response)

#### Encoding APIs

- [TextDecoder](https://developer.mozilla.org/en-US/docs/Web/API/TextDecoder)
- [TextEncoder](https://developer.mozilla.org/en-US/docs/Web/API/TextEncoder)
- [atob](https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/atob)
- [btoa](https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/btoa)

#### Web Stream APIs

- [ReadableStream](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream)
- [ReadableStreamBYOBReader](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStreamBYOBReader)
- [ReadableStreamDefaultReader](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStreamDefaultReader)
- [TransformStream](https://developer.mozilla.org/en-US/docs/Web/API/TransformStream)
- [WritableStream](https://developer.mozilla.org/en-US/docs/Web/API/WritableStream)
- [WritableStreamDefaultWriter](https://developer.mozilla.org/en-US/docs/Web/API/WritableStreamDefaultWriter)

#### Web Crypto APIs

- [crypto](https://developer.mozilla.org/en-US/docs/Web/API/Web_Crypto_API)
- [CryptoKey](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey)
- [SubtleCrypto](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto)

### Restrictions on queries and mutations

Query and mutation functions are further **restricted by the runtime to be
[deterministic](https://en.wikipedia.org/wiki/Deterministic_algorithm)**. This
allows Convex to automatically retry them by the system as necessary.

Determinism means that no matter how many times your function is run, as long as
it is given the same arguments, it will have identical side effects and return
the same value.

You don't have to think all that much about maintaining these properties of
determinism when you write your Convex functions. Convex will provide helpful
error messages as you go, so you can't *accidentally* do something forbidden.

#### Using randomness and time in queries and mutations

Convex provides a "seeded" strong pseudo-random number generator
at `Math.random()` so that it can guarantee the determinism of your function.
The random number generator's seed is an implicit parameter to your function.
Multiple calls to `Math.random()` in one function call will return different
random values. Note that Convex does not reevaluate the Javascript modules on
every function run, so a call to `Math.random()` stored in a global variable
will not change between function runs.

To ensure the logic within your function is reproducible, the system time used
globally (outside of any function) is "frozen" at deploy time, while the system
time during Convex function execution is "frozen" when the function
begins. `Date.now()` will return the same result for the entirety of your
function's execution. For example,

```javascript
const globalRand = Math.random(); // `globalRand` does not change between runs.
const globalNow = Date.now(); // `globalNow` is the time when Convex functions were deployed.

export const updateSomething = mutation({
  args: {},
  handler: () => {
    const now1 = Date.now(); // `now1` is the time when the function execution started.
    const rand1 = Math.random(); // `rand1` has a new value for each function run.
    // implementation
    const now2 = Date.now(); // `now2` === `now1`
    const rand2 = Math.random(); // `rand1` !== `rand2`
  },
});
```

### Actions

Actions are unrestricted by the same rules of determinism as query and mutation
functions. Notably actions are allowed to call third-party HTTP endpoints via
the browser-standard
[`fetch`](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) function.

By default actions also run in Convex’s custom JavaScript runtime with all of
its advantages including no cold starts and a browser-like API environment. They
can also live in the same file as your query and mutation functions.

## Node.js runtime

Some JavaScript and TypeScript libraries use features that are not included in
the default Convex runtime. Convex actions provide an escape hatch to
[Node.js 18](https://nodejs.org/en/about) via the `"use node"` directive at the
top of a file that contains your action.
[Learn more](/functions/actions.mdx#choosing-the-runtime-use-node).

Use of the Node.js environment is restricted to **action functions only**. If
you want to use a library designed for Node.js and interact with the Convex
database, you need to call the Node.js library from an action, and use
[`runQuery`](/functions/actions.mdx#action-context) or
[`runMutation`](/functions/actions.mdx#action-context) helper to call a query or
mutation.

Every `.ts` and `.js` file in the convex directory
[is bundled](/functions/bundling.mdx) either for the default Convex JavaScript
runtime or Node.js, along with any code it imports.

Files with the `"use node"` directive should not contain any Convex queries or
mutations since they cannot be run in the Node.js runtime. Additionally, files
without the `"use node"` directive should not import any files with the
`"use node"` directive. Files that contain no Convex functions, like a
`convex/utils.ts` file, also need the "use node" directive if they use
Node.js-specific libraries.

If you encounter bundling errors about Node.js-specific imports like `fs` /
`node:fs` not being available when deploying convex functions, running
`npx convex dev --once --debug-node-apis` gives more information about these. It
uses a slower bundling method to track the train of imports, narrowing down
which import is responsible for the error.

Note that argument size limits are lower (5MiB instead of 16MiB).



================================================
FILE: npm-packages/docs/docs/functions/validation.mdx
================================================
---
title: "Argument and Return Value Validation"
sidebar_label: "Validation"
sidebar_position: 50
description: "Validate function arguments and return values for security"
---

import ConvexValues from "@site/docs/_convexValues.mdx";

import messagesTS from "!!raw-loader!@site/../demos/args-validation/convex/messages.ts";

Argument and return value validators ensure that
[queries](./query-functions.mdx), [mutations](./mutation-functions.mdx), and
[actions](./actions.mdx) are called with the correct types of arguments and
return the expected types of return values.

**This is important for security!** Without argument validation, a malicious
user can call your public functions with unexpected arguments and cause
surprising results. [TypeScript](/understanding/best-practices/typescript) alone
won't help because TypeScript types aren't present at runtime. We recommend
adding argument validation for all public functions in production apps. For
non-public functions that are not called by clients, we recommend
[internal functions](/functions/internal-functions.mdx) and optionally
validation.

**Example:**
[Argument Validation](https://github.com/get-convex/convex-demos/tree/main/args-validation)

## Adding validators

To add argument validation to your functions, pass an object with `args` and
`handler` properties to the `query`, `mutation` or `action` constructor. To add
return value validation, use the `returns` property in this object:

<TSAndJSSnippet
  title="convex/message.ts"
  sourceTS={messagesTS}
  sourceJS={messagesTS}
  snippet="mutation"
/>

If you define your function with an argument validator, there is no need to
include [TypeScript](/understanding/best-practices/typescript.mdx) type
annotations! The type of your function will be inferred automatically.
Similarly, if you define a return value validator, the return type of your
function will be inferred from the validator, and TypeScript will check that it
matches the inferred return type of the `handler` function.

Unlike TypeScript, validation for an object will throw if the object contains
properties that are not declared in the validator.

If the client supplies arguments not declared in `args`, or if the function
returns a value that does not match the validator declared in `returns`. This is
helpful to prevent bugs caused by mistyped names of arguments or returning more
data than intended to a client.

Even `args: {}` is a helpful use of validators because TypeScript will show an
error on the client if you try to pass any arguments to the function which
doesn't expect them.

## Supported types

All functions, both public and internal, can accept and return the following
data types. Each type has a corresponding validator that can be accessed on the
[`v`](/api/modules/values#v) object imported from `"convex/values"`.

The [database](/database.mdx) can store the exact same set of
[data types](/database/types.md).

Additionally you can also express type unions, literals, `any` types, and
optional fields.

### Convex values

<ConvexValues />

### Unions

You can describe fields that could be one of multiple types using `v.union`:

```typescript
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export default mutation({
  args: {
    stringOrNumber: v.union(v.string(), v.number()),
  },
  handler: async ({ db }, { stringOrNumber }) => {
    //...
  },
});
```

### Literals

Fields that are a constant can be expressed with `v.literal`. This is especially
useful when combined with unions:

```typescript
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export default mutation({
  args: {
    oneTwoOrThree: v.union(
      v.literal("one"),
      v.literal("two"),
      v.literal("three"),
    ),
  },
  handler: async ({ db }, { oneTwoOrThree }) => {
    //...
  },
});
```

### Record objects

You can describe objects that map arbitrary keys to values with `v.record`:

```typescript
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export default mutation({
  args: {
    simpleMapping: v.record(v.string(), v.boolean()),
  },
  handler: async ({ db }, { simpleMapping }) => {
    //...
  },
});
```

You can use other types of string validators for the keys:

```typescript
defineTable({
  userIdToValue: v.record(v.id("users"), v.boolean()),
});
```

Notes:

- This type corresponds to the
  [Record\<K,V\>](https://www.typescriptlang.org/docs/handbook/utility-types.html#recordkeys-type)
  type in TypeScript
- You cannot use string literals as a `record` key
- Using `v.string()` as a `record` key validator will only allow ASCII
  characters

### Any

Fields that could take on any value can be represented with `v.any()`:

```typescript
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export default mutation({
  args: {
    anyValue: v.any(),
  },
  handler: async ({ db }, { anyValue }) => {
    //...
  },
});
```

This corresponds to the `any` type in TypeScript.

### Optional fields

You can describe optional fields by wrapping their type with `v.optional(...)`:

```typescript
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export default mutation({
  args: {
    optionalString: v.optional(v.string()),
    optionalNumber: v.optional(v.number()),
  },
  handler: async ({ db }, { optionalString, optionalNumber }) => {
    //...
  },
});
```

This corresponds to marking fields as optional with `?` in TypeScript.

## Extracting TypeScript types

The [`Infer`](/api/modules/values#infer) type allows you to turn validator calls
into TypeScript types. This can be useful to remove duplication between your
validators and TypeScript types:

```ts
import { mutation } from "./_generated/server";
import { Infer, v } from "convex/values";

const nestedObject = v.object({
  property: v.string(),
});

// Resolves to `{property: string}`.
export type NestedObject = Infer<typeof nestedObject>;

export default mutation({
  args: {
    nested: nestedObject,
  },
  handler: async ({ db }, { nested }) => {
    //...
  },
});
```



================================================
FILE: npm-packages/docs/docs/functions/error-handling/application-errors.mdx
================================================
---
title: "Application Errors"
sidebar_label: "Application Errors"
description: "Handle expected failures in Convex functions"
---

import Server from "!!raw-loader!@site/../private-demos/snippets/convex/applicationErrors.ts";
import ClientTS from "!!raw-loader!@site/../private-demos/snippets/src/applicationErrors.tsx";
import ClientJS from "!!raw-loader!@site/../private-demos/snippets/src/applicationErrorsJS.jsx";

If you have expected ways your functions might fail, you can either return
different values or throw `ConvexError`s.

## Returning different values

If you're using TypeScript different return types can enforce that you're
handling error scenarios.

For example, a `createUser` mutation could return

```ts
Id<"users"> | { error: "EMAIL_ADDRESS_IN_USE" };
```

to express that either the mutation succeeded or the email address was already
taken.

This ensures that you remember to handle these cases in your UI.

## Throwing application errors

You might prefer to throw errors for the following reasons:

- You can use the exception bubbling mechanism to throw from a deeply nested
  function call, instead of manually propagating error results up the call
  stack. This will work for `runQuery`, `runMutation` and `runAction` calls in
  [actions](/functions/actions.mdx) too.
- In [mutations](/functions/mutation-functions.mdx), throwing an error will
  prevent the mutation transaction from committing
- On the client, it might be simpler to handle all kinds of errors, both
  expected and unexpected, uniformly

Convex provides an error subclass,
[`ConvexError`](/api/classes/values.ConvexError), which can be used to carry
information from the backend to the client:

<TSAndJSSnippet
  title="convex/myFunctions.ts"
  sourceTS={Server}
  sourceJS={Server}
  snippet="example"
  highlightPatterns={["ConvexError"]}
/>

### Application error `data` payload

You can pass the same [data types](/database/types.md) supported by function
arguments, return types and the database, to the `ConvexError` constructor. This
data will be stored on the `data` property of the error:

```ts
// error.data === "My fancy error message"
throw new ConvexError("My fancy error message");

// error.data === {message: "My fancy error message", code: 123, severity: "high"}
throw new ConvexError({
  message: "My fancy error message",
  code: 123,
  severity: "high",
});

// error.data === {code: 123, severity: "high"}
throw new ConvexError({
  code: 123,
  severity: "high",
});
```

Error payloads more complicated than a simple `string` are helpful for more
structured error logging, or for handling sets of errors differently on the
client.

## Handling application errors on the client

On the client, application errors also use the `ConvexError` class, and the data
they carry can be accessed via the `data` property:

<TSAndJSSnippet
  title="src/App.tsx"
  sourceTS={ClientTS}
  sourceJS={ClientJS}
  highlightPatterns={["ConvexError", ".data"]}
/>



================================================
FILE: npm-packages/docs/docs/functions/error-handling/error-handling.mdx
================================================
---
title: "Error Handling"
sidebar_position: 70
description: "Handle errors in Convex queries, mutations, and actions"
---

There are four reasons why your Convex [queries](/functions/query-functions.mdx)
and [mutations](/functions/mutation-functions.mdx) may hit errors:

1. [Application Errors](#application-errors-expected-failures): The function
   code hits a logical condition that should stop further processing, and your
   code throws a `ConvexError`
1. Developer Errors: There is a bug in the function (like calling `db.get(null)`
   instead of `db.get(id)`).
1. [Read/Write Limit Errors](#readwrite-limit-errors): The function is
   retrieving or writing too much data.
1. Internal Convex Errors: There is a problem within Convex (like a network
   blip).

Convex will automatically handle internal Convex errors. If there are problems
on our end, we'll automatically retry your queries and mutations until the
problem is resolved and your queries and mutations succeed.

On the other hand, you must decide how to handle application, developer and
read/write limit errors. When one of these errors happens, the best practices
are to:

1. Show the user some appropriate UI.
2. Send the error to an exception reporting service using the
   [Exception Reporting Integration](/production/integrations/exception-reporting).
3. Log the incident using `console.*` and set up reporting with
   [Log Streaming](/production/integrations/log-streams/log-streams.mdx). This
   can be done in addition to the above options, and doesn't require an
   exception to be thrown.

Additionally, you might also want to send client-side errors to a service like
[Sentry](https://sentry.io) to capture additional information for debugging and
observability.

## Errors in queries

If your query function hits an error, the error will be sent to the client and
thrown from your `useQuery` call site. **The best way to handle these errors is
with a React
[error boundary component](https://reactjs.org/docs/error-boundaries.html).**

Error boundaries allow you to catch errors thrown in their child component tree,
render fallback UI, and send information about the error to your exception
handling service. Adding error boundaries to your app is a great way to handle
errors in Convex query functions as well as other errors in your React
components. If you are using Sentry, you can use their
[`Sentry.ErrorBoundary`](https://docs.sentry.io/platforms/javascript/guides/react/components/errorboundary/)
component.

With error boundaries, you can decide how granular you'd like your fallback UI
to be. One simple option is to wrap your entire application in a single error
boundary like:

```tsx
<StrictMode>
  <ErrorBoundary>
    <ConvexProvider client={convex}>
      <App />
    </ConvexProvider>
  </ErrorBoundary>
</StrictMode>,
```

Then any error in any of your components will be caught by the boundary and
render the same fallback UI.

On the other hand, if you'd like to enable some portions of your app to continue
functioning even if other parts hit errors, you can instead wrap different parts
of your app in separate error boundaries.

<Admonition type="note" title="Retrying">

Unlike other frameworks, there is no concept of "retrying" if your query
function hits an error. Because Convex functions are
[deterministic](/functions/query-functions.mdx#caching--reactivity--consistency),
if the query function hits an error, retrying will always produce the same
error. There is no point in running the query function with the same arguments
again.

</Admonition>

## Errors in mutations

If a mutation hits an error, this will

1. Cause the promise returned from your mutation call to be rejected.
2. Cause your [optimistic update](/client/react/optimistic-updates.mdx) to be
   rolled back.

If you have an exception service like [Sentry](https://sentry.io/) configured,
it should report "unhandled promise rejections" like this automatically. That
means that with no additional work your mutation errors should be reported.

Note that errors in mutations won't be caught by your error boundaries because
the error doesn't happen as part of rendering your components.

If you would like to render UI specifically in response to a mutation failure,
you can use `.catch` on your mutation call. For example:

```javascript
sendMessage(newMessageText).catch((error) => {
  // Do something with `error` here
});
```

If you're using an `async` handled function you can also use `try...catch`:

```javascript
try {
  await sendMessage(newMessageText);
} catch (error) {
  // Do something with `error` here
}
```

<Admonition type="caution" title="Reporting caught errors">

If you handle your mutation error, it will no longer become an unhandled promise
rejection. You may need to report this error to your exception handling service
manually.

</Admonition>

## Errors in action functions

Unlike queries and mutations, [actions](//docs/functions/actions.mdx) may have
side-effects and therefore can't be automatically retried by Convex when errors
occur. For example, say your action sends a email. If it fails part-way through,
Convex has no way of knowing if the email was already sent and can't safely
retry the action. It is responsibility of the caller to handle errors raised by
actions and retry if appropriate.

## Differences in error reporting between dev and prod

Using a dev deployment any server error thrown on the client will include the
original error message and a server-side stack trace to ease debugging.

Using a production deployment any server error will be redacted to only include
the name of the function and a generic `"Server Error"` message, with no stack
trace. Server
[application errors](/functions/error-handling/application-errors.mdx) will
still include their custom `data`.

Both development and production deployments log full errors with stack traces
which can be found on the [Logs](/dashboard/deployments/logs.md) page of a given
deployment.

## Application errors, expected failures

If you have expected ways your functions might fail, you can either return
different values or throw `ConvexError`s.

See [Application Errors](/functions/error-handling/application-errors.mdx).

## Read/write limit errors

To ensure uptime and guarantee performance, Convex will catch queries and
mutations that try to read or write too much data. These limits are enforced at
the level of a single query or mutation function execution. The limits are:

Queries and mutations error out when:

- More than 16384 documents are scanned
- More than 8MiB worth of data is scanned
- More than 4096 queries calls to `db.get` or `db.query` are made
- The function spends more than 1 second executing Javascript

In addition, mutations error out when:

- More than 8192 documents are written
- More than 8MiB worth of data is written

Documents are "scanned" by the database to figure out which documents should be
returned from `db.query`. So for example `db.query("table").take(5).collect()`
will only need to scan 5 documents, but `db.query("table").filter(...).first()`
might scan up to as many documents as there are in `"table"`, to find the first
one that matches the given filter.

Number of calls to `db.get` and `db.query` has a limit to prevent a single query
from subscribing to too many index ranges.

In general, if you're running into these limits frequently, we recommend
[indexing your queries](/database/reading-data/indexes/indexes.md) to reduce the
number of documents scanned, allowing you to avoid unnecessary reads. Queries
that scan large swaths of your data may look innocent at first, but can easily
blow up at any production scale. If your functions are close to hitting these
limits they will log a warning.

For information on other limits, see [here](/production/state/limits.mdx).

## Debugging Errors

See [Debugging](/functions/debugging.mdx) and specifically
[Finding relevant logs by Request ID](/functions/debugging.mdx#finding-relevant-logs-by-request-id).


